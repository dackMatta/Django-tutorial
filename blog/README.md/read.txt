#To create our first django project run the command
PS C:\Users\Administrator\Documents\Django tutorial\practice> django-admin.exe startproject mypractice .

#Changing settings
TIME_ZONE = 'Europe/Berlin'---specify the time TIME_ZONE
LANGUAGE_CODE = 'de-ch'---specify the LANGUAGE_CODE
STATIC_URL = '/static/'
STATIC_ROOT = BASE_DIR / 'static'----add a path for static files
ALLOWED_HOSTS = ['127.0.0.1', '.pythonanywhere.com']

#Set up a database
python manage.py migrate---run on the console to create the database

#Starting the web server
python manage.py runserver---run on the console to start the web server

#Django models
A model in Django is a special kind of object – it is saved in the database
An object  is a collection of properties and actions.

#Creating an application
To keep everything tidy, we will create a separate application inside our project
python manage.py startapp blog---run on the console to create the application
navigate to the setting.py and add the path
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'blog',------we added the app to the installed INSTALLED_APPS
]

#Creating a blog post model
navigate to models.py in our blog app and create the objects in this case

from django.conf import settings
from django.db import models
from django.utils import timezone


class Post(models.Model):
    author = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    title = models.CharField(max_length=200)
    text = models.TextField()
    created_date = models.DateTimeField(default=timezone.now)
    published_date = models.DateTimeField(blank=True, null=True)

    def publish(self):
        self.published_date = timezone.now()
        self.save()

    def __str__(self):
        return self.title

an explanaition of the above code

we have created a class with the name Post
models.Model means that the Post is a Django Model, so Django knows that it should be saved in the database.
models.CharField – this is how you define text with a limited number of characters.
models.TextField – this is for long text without a limit.
models.DateTimeField – this is a date and time.
models.ForeignKey – this is a link to another model.

def publish(self):---means that this is a function/method and publish is the name of the method.
 The naming rule is that we use lowercase and underscores instead of spaces
  we need to indent our methods inside the class

#Create tables for models in your database
 python manage.py makemigrations blog ----run the command on the console/terminal to add our new model to our database. 
 python manage.py migrate blog -----run the command on the console/terminal to apply our file to our database. 

#Django admin
To add, edit and delete the posts we've just modeled, we will use Django admin
Let's open the blog/admin.py file in the code editor and replace its contents with this:

  from django.contrib import admin
  from .models import Post

  admin.site.register(Post)

python manage.py runserver---run on the console/terminal to run the web server
 Go to your browser and type the address http://127.0.0.1:8000/admin/. 
 To log in, you need to create a superuser - a user account that has control over everything on the site.
 python manage.py createsuperuser---run this command on the terminal
 bonous point---Remember, to write new commands while the web server is running, open a new terminal window
 When prompted, type your username (lowercase, no spaces), email address, and password.
 Return to your browser. Log in with the superuser's credentials you chose
 Go to Posts and experiment a little bit with it. Add five or six blog posts.

 #Deploy!
 Deploying is the process of publishing your application on the Internet so people can finally go and see your app.
 we're going to use PythonAnywhere. 
 PythonAnywhere is free for small applications that don't have too many visitors so it'll definitely be enough for you now

 Setting up our blog on PythonAnywhere
 Sign up for a PythonAnywhere account

 #Creating a PythonAnywhere API token
 Find the link near the top right to your "Account" page:
 then select the tab named "API token", and hit the button that says "Create new API token".

#Configuring our site on PythonAnywhere
Go back to the main PythonAnywhere Dashboard by clicking on the logo,
choose the option to start a "Bash" console – that's the PythonAnywhere version of a command line.
 Deploying a web app on PythonAnywhere involves pulling down your code from GitHub,
  and then configuring PythonAnywhere to recognise it and start serving it as a web application.
  pip3.8 install --user pythonanywhere ---prompt the  command line to install the python anywhere application

  .......i got stack with pythoneverywhere.....

#Django URLs
A URL is a web address. You can see a URL every time you visit a website

 add a line that will import blog.urls
 navigate to the urls.py in mypractice and add the following:
   
   from django.contrib import admin
   from django.urls import path, include
   urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('blog.urls')),---we have added this path

   ]

#blog.urls
Create a new empty file named urls.py in the blog directory,
add the following code to the file
  from django.urls import path
  from . import views

Here we're importing Django's function path and all of our views from the blog application
we then add the following to the urls.py file

  urlpatterns = [
    path('', views.post_list, name='post_list'),
  ]

  *an explanaition of the code components above:
   we have  assigninged a view called post_list to the root URL
   name='post_list', is the name of the URL that will be used to identify the view.
   keep the names of URLs unique and easy to remember.

#Django views 
A view is a place where we put the "logic" of our application
It will request information from the model you created before and pass it to a template
Views are placed in the views.py file. We will add our views to the blog/views.py file.

#blog/views.py
def post_list(request):
    return render(request, 'blog/post_list.html', {})

    *an explanaition of the code components above:
     we created a function (def) called post_list,
     the function takes request and will return the value it gets from calling another function render that will render (put together) our template

#Your first template!
Templates are saved in blog/templates/blog directory.
 first create a directory called templates inside your blog directory.
 Then create another directory called blog inside your templates directory:
 And now create a post_list.html file inside the blog/templates/blog directory.
 in your post_list.html file add the content you want to be displayed on your webpage
 *note that django templetes are case sensitive 


#Django ORM and QuerySets
here we learn how Django connects to the database and stores data in it.
A QuerySet is, in essence, a list of objects of a given Model.
QuerySets allow you to read the data from the database, filter it and order it.

#Django shell
type this command on the terminal
 >>>python manage.py shell
next we need to import post from blog.models in that case
type this command on the terminal
 >>>from blog.models import Post
after importing post,
on the terminal prompt
 >>>Post.objects.all()
the terminal returns a list of the posts we created earlier! We created these posts using the Django admin interface.

#Create object
to create a new object in database using python,
Let's import User model first:
on the terminal
 >>>from django.contrib.auth.models import User
check the number of users with this prompt
>>>User.objects.all()
to  get an instance of the user now
 >>>me = User.objects.get(username='dackmattamac')
Now we can finally create our post:
 >>>Post.objects.create(author=me, title='Sample title', text='Test')
 >>>Post.objects.create(author=me, title='beats producers', text='Test')
 >>>Post.objects.create(author=me, title='record labels', text='Test')
to check if it worked
 >>>Post.objects.all()

#Filter objects
A big part of QuerySets is the ability to filter them.
we can filter the QuerySet to get a list based on their content
 >>>Post.objects.filter(title__contains='title')
 >>>Post.objects.filter(title__contains='top')

You can also get a list of all published posts.
First get an instance of a post we want to publish in this case:
 >>> post = Post.objects.get(title="Sample title")

#Ordering objects
QuerySets also allow you to order the list of objects
We can reverse the ordering by adding - at the beginning:
 >>>Post.objects.order_by('-created_date')

 To close the shell, type this:
     >>>exit()



  


   



